/**
 *
 * 回溯算法（深度优先遍历）场景有这么几类：
 * 1、排列：全排列
 * 2、组合：与全排列一个意思，但是不考虑顺序。[1, 2, 3], [1, 3, 2], [3, 1, 2]只能算一个种组合
 * 3、子集：与组合一个意思，但是组合长度不固定，从0 ~ n都可以。（n是给出组合的长度）
 *
 * 在代码中典型的回溯算法套路中，什么时候回溯递归的循环起始值从0开始，什么时候从搜索深度开始？
 * 以及什么时候需要引入一个used[] boolean数组，以及什么时候需要剪枝等？
 *
 * 以下做一个小节：
 * 1、全排列的回溯递归循环起始位要从0开始，这样保证每个节点都可以root节点下的一个分支，被深度优先算法搜索一遍。
 *      同样，在搜索路径中，为了避免使用了重复的值，因此需要引入一个used[] boolean数组。
 *      进一步地，如果给定的数组中包含重复值，那么首先要对数组有个排序，根据条件 (i > 0 && used[i] == used[i-1] && !used[i-1])来剪枝
 * 2、组合的选择中，为了避免挑选出[1, 2, 3], [2, 1, 3]这样相同的组合，组合回溯递归循环起始位从当期递归搜索深度开始，避免挑选到当期深度之前的节点
 *      同样，因为每一层递归循环的起始位从当前深度开始，就无效担心会选到之前的节点，used[] boolean数组也就无需引入
 * 3、子集，与组合类似，但是不需要考虑组合的长度问题，每搜索一个节点，都把新的组装的path压入子集的结构中。
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 * @author liuh
 * @email hong.liu@dmall.com
 * @date 2020/9/16
 */
package com.reallx.algrithm.dfs;

